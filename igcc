#!/usr/bin/env bash
# igcc - Yet another interactive shell for C development
# Copyright (C) 2018 TANI Kojiro <kojiro0531@gmail.com>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
readonly version="0.0.1"
readonly copy="(C) 2018 TANI Kojiro <kojiro0531@gmail.com>"

lines=()
count=0
libs=()
std=gnu11
gccversion=$(gcc --version | grep ^gcc)
headers=(stdio.h)
prog=$(basename $0)

readonly runtime="\
#define __fmt_string(v) _Generic((v),\\
  char*:\"\\x1b[34m\$%d\\x1b[0m = (string)\\\"%s\\\"\\n\",\\
  char:\"\\x1b[34m\$%d\\x1b[0m = (char)\\'%c\\'\\n\",\\
  int:\"\\x1b[34m\$%d\\x1b[0m = (int)%d\\n\",\\
  long:\"\\x1b[34m\$%d\\x1b[0m = (long)%ld\\n\",\\
  float:\"\\x1b[34m\$%d\\x1b[0m = (float)%f\\n\",\\
  double:\"\\x1b[34m\$%d\\x1b[0m = (double)%f\\n\",\\
  unsigned int:\"\\x1b[34m\$%d\\x1b[0m = (unsigned int)%u\\n\",\\
  unsigned long:\"\\x1b[34m\$%d\\x1b[0m = (unsigned long)%lu\\n\",\\
  default:\"\\x1b[34m\$%d\\x1b[0m = (unknown type)%p\\n\")

#define __print(v) printf(__fmt_string(v), COUNT, v)
"

readonly template="\
#define __code %s
int main (void)
{
#ifdef PRINT
  __print(({__code}));
#else
  __code
  printf(\"\\x1b[34m\$%%d\\x1b[0m = (void)\\\\n\", COUNT);
#endif
  return 0;
}
"

function print-error() {
  printf "\e[31mError:$1\e[m\n"
}

function print-success() {
  printf "\e[34m$1\e[m\n"
}

function prompt() {
  printf "\e[35m$std\e[32m@\e[33m($prog)\e[32m> \e[m"
}

function exit-with-prompt () {
  local response
  echo
  read -r -p "Do you really want to exit ([y]/n)? " response
  if [ "$response" = "y" -o -z "$response" ]; then
    exit 0
  fi
}

function add-semicolon-if-needed () {
  if [[ "${1: -1}" = ";" ]]; then
    echo "$1"
  else
    echo "$1;"
  fi
}

function create-source () {
  local i
  local body="freopen(\"/dev/null\", \"w\", stdout);"
  for ((i = 0; i < $count - 1; i++)); do
    body+="({$(add-semicolon-if-needed ${lines[i]})"
  done
  body+="({freopen(\"/dev/tty\", \"w\", stdout);\
    $(add-semicolon-if-needed ${lines[i]})\
    $(printf "});%.0s" ${lines[@]})"
  local include
  local header
  for header in ${headers[@]}; do
    include+="#include \"$header\"\n"
  done
  include="$(IFS= printf "$include")"
  printf "%s\n%s\n$template\n" $include "$runtime" "$body"
}

function compile-and-run () { 
  local bin=$(mktemp)
  local result
  local src="$(create-source)"
  echo $src | gcc -xc -std=$std -o $bin -DPRINT \
    -DCOUNT=$count ${libs[@]} - >/dev/null 2>&1 || \
  echo $src | gcc -xc -std=$std -o $bin \
    -DCOUNT=$count ${libs[@]} - >/dev/null 2>&1
  if [ -x $bin ]; then
    result=$($bin || echo failed)
    if [ ! -z "$result" ]; then
      let count--
      lines="(${lines[@]:0:$count})"
      print-error "Segmentation fault."
    fi
 else
    let count--
    lines=(${lines[@]:0:$count})
    print-error "Failed to compile."
  fi
  rm -f $bin
}

function command-help () {
  cat << EOS
    :exit               exit $prog.
    :help               show this help.
    :include <header>   add header file.
    :lib <library>      add shared library to be linked.
    :load <file>        restore enviroment from <file>.
    :save <file>        save current environment into <file>.      
EOS
}

function command-include () {
  local header=$2
  if [ -z $header ]; then
    print-success "(${headers[*]})"
  else
    if [ -z $(echo "${headers[@]}" | grep -o $header) ]; then
      if [ -z $(echo \#include \"$header\" |\
              gcc -xc - 2>&1 | grep -o $header) ]; then
        headers+=("$header")
      else
        print-error "Could not find \`$header\`."
      fi
    fi
    print-success "(${headers[*]})"
  fi
}

function command-lib () {
  local lib=$2
  if [ -z $lib ]; then
    IFS= print-success "(${libs[*]})"
  else
    if [ -z $(echo "${libs[@]}" | grep -o $lib) ]; then
      if [ -z $(gcc -l$2 2>&1 | grep -o main) ]; then
        print-error "Could not find \`lib$lib.so\`."
      else
        libs+=("-l$lib")
      fi
    fi
    IFS= print-success "(${libs[*]})"
  fi
}

function command-load () {
  local file=$2
  if [ -z $file ]; then
    print-error "Missing filename."
  else
    if source $(realpath $file) >/dev/null 2>&1; then
      print-success "Loaded.:\`$file\`"
    else
      print-error "Failed to load from \`$file\`."
    fi
  fi
}

function command-save () {
  local file=$2
  if [ -z $file ]; then
    print-error "Missing filename."
  else
    cat << EOS > $file
lib=(${libs[@]})
headers=(${headers[@]})
lines=($(printf "\"%s\" " "${lines[@]}"))
count=$count
EOS
   print-success "Wrote into \`$file\`."
  fi
}

function main-loop () {
  local line
  while true; do
    IFS= read -er -p "$(prompt)" line
    history -s "$line"
    if [ -z "$line" ]; then
      exit-with-prompt
    elif [ "$line" = ":exit" ]; then
      exit 0
    elif [ "$line" = ":help" ]; then
      command-help
    elif [[ $line = :include\ * ]]; then
      command-include $line
    elif [[ $line = :lib\ * ]]; then
      command-lib $line
    elif [[ $line = :load\ * ]]; then
      command-load $line
    elif [[ $line = :save\ * ]]; then
      command-save $line
    elif [[ $line = :* ]]; then
      print-error "Invalid command or missing arguments. try \`:help\`."
    elif [[ $line = \#* ]]; then
      print-error "CPP directive is not allowed. \`try :help\`."
    else
      local _IFS="$IFS"
      IFS= lines+=("$line")
      let count++
      compile-and-run
      IFS="$_IFS"
    fi
    echo
  done
}

function show-help-and-exit () {
  cat << EOS
Usage: $prog [options]
Options:
  -h	show this help and exit.
  -v	show version info and exit.
EOS
  exit 1
}

function show-version-and-exit () {
  echo $prog $version
  exit 1
}

function main () {
  local opt
  while getopts vh opt; do
    case $opt in
      v) show-version-and-exit
        ;;
      h) show-help-and-exit
        ;;
      \?) show-help-and-exit
        ;;
    esac
  done
  if [ $# -gt 0 ]; then
    show-help-and-exit
  fi
  shift $((OPTIND - 1))
  if [ $# -gt 1 ]; then
    show-help-and-exit
  fi
  cat << EOS
$prog $version with $gccversion
$copy
try \`:help\` to get help. Ctrl-D to exit.

EOS
  main-loop
}

main $@
